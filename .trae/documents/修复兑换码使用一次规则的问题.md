## 问题分析

经过仔细检查，我发现兑换码没有被正确标记为已使用的原因是：在 `saveTestResult` 函数中，调用 `utils.markCodeAsUsed(testState.currentCode);` 后，又调用了 `utils.saveData(data);`，这导致 `usedCodes` 数组被覆盖。

具体问题流程：
1. `saveTestResult` 函数获取数据：`const data = utils.getData();`
2. 修改 `testResults` 对象：`data.testResults[testState.currentCode] = result;`
3. 调用 `utils.markCodeAsUsed(testState.currentCode);` - 这个函数会获取新数据，修改 `usedCodes` 数组并保存
4. 调用 `utils.saveData(data);` - 保存的是步骤1获取的数据，不包含步骤3中修改的 `usedCodes` 数组，导致覆盖

## 修复方案

修改 `saveTestResult` 函数的调用顺序，确保数据被正确保存：

1. 在 `test.html` 文件中，修改 `saveTestResult` 函数：
   - 移除 `utils.markCodeAsUsed(testState.currentCode);` 调用
   - 直接在函数中添加兑换码到 `usedCodes` 数组
   - 只调用一次 `utils.saveData(data);`

## 修复后的代码

```javascript
// 保存测评结果
function saveTestResult(type, scores, totalScores) {
    const data = utils.getData();
    const result = {
        code: testState.currentCode,
        basicInfo: testState.basicInfo,
        scores: scores,
        totalScores: totalScores,
        type: type,
        timestamp: new Date().toISOString()
    };
    
    // 保存测评结果
    data.testResults[testState.currentCode] = result;
    
    // 标记兑换码为已使用
    if (!data.usedCodes.includes(testState.currentCode)) {
        data.usedCodes.push(testState.currentCode);
    }
    
    // 只保存一次数据
    utils.saveData(data);
}
```

## 验证方法

1. 生成一个新的兑换码
2. 使用该兑换码进行测评
3. 完成测评后，检查后台兑换码状态是否为已使用
4. 再次使用相同的兑换码，应该提示无效或已使用

这个修复方案确保了兑换码在使用后会被正确标记为已使用，并且只能使用一次。